import random
import pygame
import sys
import cv2
import mediapipe as mp
from pygame.locals import *
import os
import subprocess

os.environ['SDL_VIDEO_WINDOW_POS'] = "1000,100"  # position X=100, Y=100

import sys, os, subprocess, webbrowser
from pathlib import Path

file = "escap_game.html"
HTML_FILE = (Path(file).parent / "escape_game.html").resolve()

# =========================
# INITIALISATION
# =========================
pygame.init()
pygame.font.init()

# -------------------------
# MOT DE PASSE / AUTH
# -------------------------
PASSWORD = "E7"
authenticated = False
input_text = ""
font = pygame.font.SysFont(None, 48)

# -------------------------
# CONFIGURATION
# -------------------------
SEED = 10
tile_size_target = 50
player_image_path = "player.png"
show_maze = True

# -------------------------
# FENÊTRE INITIALE POUR MOT DE PASSE
# -------------------------
window = pygame.display.set_mode((1200, 1000), pygame.ANYFORMAT)
pygame.display.set_caption("EK47")

def draw_password_screen(surface, prompt="ACCES SERVEUR (Indice: 2 caractères attendus) : "):
    surface.fill((20, 20, 20))
    prompt_surf = font.render(prompt, True, (255, 255, 255))
    surface.blit(prompt_surf, (50, 50))
    obscured = "*" * len(input_text)
    input_surf = font.render(obscured, True, (255, 255, 255))
    surface.blit(input_surf, (50, 120))
    hint = font.render("ENTER pour valider", True, (180,180,180))
    surface.blit(hint, (50, 200))
    pygame.display.flip()

# =========================
# INITIALISATION VARIABLES
# =========================
player_posx = player_posy = 0
neutral_x = neutral_y = None
move_cooldown = 0
score = 0
touched = []

# =========================
# AUTHENTIFICATION
# =========================
clock = pygame.time.Clock()
running = True
cap = None

webbrowser.open('https://www.youtube.com/watch?v=gxvCBV7oj34&list=RDgxvCBV7oj34&start_radio=1')
while running:
    if not authenticated:
        for event in pygame.event.get():
            if event.type == QUIT:
                running = False
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    running = False
                elif event.key == K_BACKSPACE:
                    input_text = input_text[:-1]
                elif event.key in (K_RETURN, K_KP_ENTER):
                    if input_text == PASSWORD:
                        authenticated = True
                        input_text = ""

                        # Initialisation plein écran
                        info = pygame.display.Info()
                        screen_w, screen_h = info.current_w, info.current_h
                        screen_w, screen_h = 1200, 800
                        window = pygame.display.set_mode((screen_w, screen_h))
                        pygame.display.set_caption("Maze Face Control")
                        os.environ['SDL_VIDEO_WINDOW_POS'] = "1000,100"  # position X=100, Y=100

                        

                        # Calcul de taille de tuile
                        ref_width = 400
                        ref_tile_count_x = max(1, ref_width // tile_size_target)
                        tile_size = max(8, screen_w // ref_tile_count_x)
                        border_x = screen_w // tile_size
                        border_y = screen_h // tile_size

                        # Positions joueur & but
                        goal_posx = border_x - 1
                        goal_posy = border_y - 1

                        # Chargement image joueur
                        if os.path.exists(player_image_path):
                            player_image = pygame.image.load(player_image_path).convert_alpha()
                            player_image = pygame.transform.scale(player_image, (tile_size, tile_size))
                        else:
                            player_image = pygame.Surface((tile_size, tile_size))
                            player_image.fill((0, 0, 255))

                        # Génération du labyrinthe
                        random.seed(SEED)
                        maze_w, maze_h = border_x, border_y
                        maze = [[{'visited': False, 'walls': {'up': True, 'down': True, 'left': True, 'right': True}}
                                 for _ in range(maze_h)] for _ in range(maze_w)]

                        def generate_maze_dfs(x=0, y=0):
                            maze[x][y]['visited'] = True
                            directions = ['up', 'down', 'left', 'right']
                            random.shuffle(directions)
                            for direction in directions:
                                nx, ny = x, y
                                if direction == 'up': ny -= 1
                                elif direction == 'down': ny += 1
                                elif direction == 'left': nx -= 1
                                elif direction == 'right': nx += 1
                                if 0 <= nx < maze_w and 0 <= ny < maze_h and not maze[nx][ny]['visited']:
                                    maze[x][y]['walls'][direction] = False
                                    opposite = {'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left'}
                                    maze[nx][ny]['walls'][opposite[direction]] = False
                                    generate_maze_dfs(nx, ny)

                        generate_maze_dfs()

                        def is_wall(x, y, direction):
                            if not (0 <= x < maze_w and 0 <= y < maze_h):
                                return True
                            return maze[x][y]['walls'].get(direction, True)

                        def draw_maze(surface):
                            if not show_maze:
                                surface.fill((30, 30, 30))
                                surface.blit(player_image, (player_posx * tile_size, player_posy * tile_size))
                                return

                            surface.fill((30, 30, 30))
                            for x in range(maze_w):
                                for y in range(maze_h):
                                    rect_color = (50, 200, 200) if (x, y) in touched else (0, 0, 0)
                                    if (x, y) == (goal_posx, goal_posy):
                                        rect_color = (255, 0, 0)
                                    pygame.draw.rect(surface, rect_color,
                                        (x * tile_size, y * tile_size, tile_size, tile_size))

                                    walls = maze[x][y]['walls']
                                    if walls.get('right', True):
                                        pygame.draw.line(surface, (100, 100, 100),
                                            (x * tile_size + tile_size, y * tile_size),
                                            (x * tile_size + tile_size, y * tile_size + tile_size), 3)
                                    if walls.get('down', True):
                                        pygame.draw.line(surface, (100, 100, 100),
                                            (x * tile_size, y * tile_size + tile_size),
                                            (x * tile_size + tile_size, y * tile_size + tile_size), 3)

                            surface.blit(player_image, (player_posx * tile_size, player_posy * tile_size))

                        # Initialisation caméra et face detection
                        mp_face = mp.solutions.face_detection
                        face_detector = mp_face.FaceDetection(0.5)
                        cap = cv2.VideoCapture(0)
                    else:
                        input_text = ""
                else:
                    if event.unicode and ord(event.unicode) >= 32:
                        input_text += event.unicode
        draw_password_screen(window)
        clock.tick(30)
        continue

    # =========================
    # === PARTIE PRINCIPALE ===
    # =========================
    ret, frame = cap.read()
    if not ret:
        continue

    frame = cv2.flip(frame, 1)
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = face_detector.process(frame_rgb)

    if result.detections:
        for detection in result.detections:
            bbox = detection.location_data.relative_bounding_box
            h, w, _ = frame.shape
            x = int(bbox.xmin * w + bbox.width * w / 2)
            y = int(bbox.ymin * h + bbox.height * h / 2)

            if neutral_x is None:
                neutral_x, neutral_y = x, y

            dx = x - neutral_x
            dy = y - neutral_y
            threshold = 35

            color = (0,0,255) if abs(dx) <= threshold and abs(dy) <= threshold else (0,255,0)
            x_min = int(bbox.xmin * w)
            y_min = int(bbox.ymin * h)
            box_width = int(bbox.width * w)
            box_height = int(bbox.height * h)
            cv2.rectangle(frame, (x_min, y_min), (x_min+box_width, y_min+box_height), color, 4)

            move_cooldown += 1
            if move_cooldown > 10:
                if dx > threshold and not is_wall(player_posx, player_posy,'right'):
                    player_posx = min(player_posx + 1, maze_w - 1)
                elif dx < -threshold and not is_wall(player_posx, player_posy,'left'):
                    player_posx = max(player_posx - 1, 0)
                elif dy > threshold and not is_wall(player_posx, player_posy,'down'):
                    player_posy = min(player_posy + 1, maze_h - 1)
                elif dy < -threshold and not is_wall(player_posx, player_posy,'up'):
                    player_posy = max(player_posy - 1, 0)
                move_cooldown = 0

    # Victoire ?

    draw_maze(window)
    pygame.display.flip()

    if (player_posx, player_posy) == (goal_posx, goal_posy):
        pygame.display.flip()
        pygame.time.wait(500)   # petit délai visuel
        running = False
        break

    # Caméra
    frame = cv2.resize(frame, (0, 0), fx=0.20, fy=0.20)
    cv2.imshow("Face Control", frame)
    cv2.moveWindow("Face Control", -50, -100)  # (x, y) position



    if cv2.waitKey(1) & 0xFF == 27:
        running = False

    # Événements clavier
    for event in pygame.event.get():
        if event.type == QUIT:
            running = False
        elif event.type == KEYDOWN:
            if event.key == K_ESCAPE:
                running = False
            elif event.key == K_r:
                random.seed(SEED)
                for x in range(maze_w):
                    for y in range(maze_h):
                        maze[x][y] = {'visited': False, 'walls': {'up': True, 'down': True, 'left': True, 'right': True}}
                generate_maze_dfs()
                player_posx = player_posy = 0

    clock.tick(30)

# ---- sortie de la boucle ----
if cap is not None:
    cap.release()
cv2.destroyAllWindows()
pygame.quit()

# Ouvrir le HTML uniquement après la victoire
try:
    if sys.platform.startswith("win"):
        os.startfile(str(HTML_FILE))
    elif sys.platform == "darwin":
        subprocess.Popen(["open", str(HTML_FILE)])
    else:
        subprocess.Popen(["xdg-open", str(HTML_FILE)])
except Exception:
    webbrowser.open_new(HTML_FILE.as_uri())
sys.exit(0)
